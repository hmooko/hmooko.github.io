---
layout: post
title: "컴퓨터 네트워크 2"
subtitle: "Chapter2. APplication Layer"
date: 2023-03-26 23:45:13 -0400
background: '/img/network(1.1~1.4)/01.jpg'
---

<h1>2.1 Principles of Network Application</h1>
<h2>Some network apps</h2>
<ul>
<li>e-mail</li>
<li>ftp</li>
<li>web</li>
<li>text messaging</li>
</ul>
<h2>TCP/IP protocol layers(Application Protocols)</h2>
<p>client와 server가 통신할 때 protocol이 있어야 한다.</p>
<p>프로토콜의 종류</p>
<ul>
<li>Name System
<ul>
<li>DNS</li>
</ul>
</li>
<li>Host config
<ul>
<li>BOOTP</li>
<li>DHCP</li>
</ul>
</li>
<li>Email
<ul>
<li>SMTP</li>
<li>POP</li>
</ul>
</li>
<li>File Transfer
<ul>
<li>FTP</li>
<li>TFTP</li>
</ul>
</li>
<li>Web
<ul>
<li>HTTP</li>
</ul>
</li>
</ul>
<h2>Creating a network app</h2>
<p>우리가 응용프로그램을 제작할 때 네트워크까지 만들어야 하는 것은 아니다. 그러한 것들은 운영체제가 담당한다.</p>
<h2>Application S/W 개발 기술</h2>
<ul>
<li>Client 쪽 개발 언어
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
</ul>
</li>
<li>Server 단 개발 언어
<ul>
<li>ASP</li>
<li>Jsp</li>
<li>Php</li>
</ul>
</li>
</ul>
<p>웹 개발 언어 및 플랫폼
Ruby
Spring</p>
<h2>Application architecture</h2>
<p>possible structure of applications:</p>
<ul>
<li>client-server : 예전부터 널리 사용됨(전통적 )</li>
<li>peer-to-peer (P2P) : pc 와 n/w 성능이 향상</li>
<li>두 모델의 Hybrid 형태</li>
</ul>
<h2>C/S vs P2P 구조</h2>
<p>C/S는 모든 client가 server와 연결되어있기 때문에 server에 부담이 집중된다.
그렇기 때문에 client와 server가 정해져 있는데 P2P는 client와 server가 고정되어있지 않다.</p>
<h2>CLient-Server architecture</h2>
<ul>
<li>server
<ul>
<li>always-on host</li>
<li>permanent IP address</li>
<li>data centers for scaling</li>
<li>Cloud computer</li>
<li>Data Center</li>
</ul>
</li>
<li>client
<ul>
<li>communicate with server</li>
<li>may be intermittently connected</li>
<li>may have dynamic IP addresses</li>
<li>do not communicate directly with each other</li>
</ul>
</li>
</ul>
<h2>Cloud computing</h2>
<p>IaaS(Infrastructure as a Service)</p>
<ul>
<li>컴퓨터 및 데이터 스토리지 제공</li>
</ul>
<p>PaaS(Platform as a Service)</p>
<ul>
<li>애플리케이션 개발과 관리 환경을 제공</li>
</ul>
<p>SaaS (Software as a Service)</p>
<ul>
<li>특정 소프트웨어 제공 (예. 웹 메일)</li>
</ul>
<h2>P2P architecture</h2>
<p>server가 고정되있지 않아 확장성이 좋다.</p>
<h2>Sockets: later on</h2>
<p>만약 우리가 정보를 주고 받는 기능까지 구현한다면 부담이 커질 것이기 때문에 운영체제에서는 이를 도와주는 API를 제공해주고 이를 Socket이라고 한다.</p>
<h2>Socket program 구조</h2>
<p>client에서는 socket을 만들고 server에서도 socket을 만든다 하지만 server에서는 그 후에 bind를 하고 연결 요청이 오기를 기다린다. client가 connect를 요청하면 server는 accept를 한 후 client와 server는 send()/recv()를 통해 데이터를 주고 받고 close()한다.</p>
<h2>Addressing process (IP: later on)</h2>
<p>네트워크 통신을 할 때 IP 주소를 통해 컴퓨터까지는 찾아갈 수 있다. 하지만 그 컴퓨터 안에서도 많은 프로세스가 돌아가고 그 컴퓨터의 특정한 프로세스를 찾아가기 위해서는 port를 통해 찾아낼 수 있다.</p>
<h2>App-layer protocol defines</h2>
<ul>
<li>types of messages exchanged</li>
<li>message syntax</li>
<li>message semantics</li>
<li>ruls for when and how processes send &amp; respond to messages</li>
</ul>
<h2>What transport service does an app need?</h2>
<ul>
<li>Data integrity (신뢰성)</li>
<li>Timing (시간)</li>
<li>Throughput (전송률)</li>
<li>Security (암호화)</li>
</ul>
<h2>Internet transport protocols services</h2>
<ul>
<li>TCP
<ul>
<li>정보를 교환했는지 확인하기 때문에 믿을 수 있다.</li>
<li>flow control: 보내는 속도 조절</li>
<li>congestion control</li>
<li>does not provide: timing, munimum throughput, guarantee, security</li>
<li>connection-oriented</li>
</ul>
</li>
<li>UDP
<ul>
<li>보내기만 하기 때문에 정보를 제대로 교환했는지 확인할 수 없다.</li>
</ul>
</li>
</ul>
<h1>2.2 Web and HTTP</h1>
<h2>Web and HTTP</h2>
<p>웹은 문서 객체로 이루어져 있고 객체는 html 파일이나 JPEC 이미지 등이 될 수 있으며 각각의 객체들은 URL이라는 주소로 위치를 나타낼 수 있다.</p>
<h2>HTTP overview</h2>
<p>만약 웹 브라우저를 통해 통신한다면 HTTP 프로토콜을 쓰고 있다고 생각하면 된다. HTTP 프로토콜은 TCP 를 사용한다. 웹 서버의 기본 포트 번호로는 80을 쓰며 보안을 위해 8000이나 8080을 쓰기도 한다. https의 경우 443을 사용한다. HTTP 1.1 이전에는 비지속성 연결을 사용했지만 지금은 지속성 연결을 사용하고 있다.</p>
<h2>비지속성 연결</h2>
<ul>
<li>RTT: 패킷이 client -&gt; server -&gt; client로 다시 돌아오는데 걸리는 시간</li>
<li>HTTP 응답 시간: TCP를 사용하기 때문에 제대로 통신이 되는지 확인하는데 RTT 한번 데이터를 통신하는데 파일 전송 시간과 RTT 한번을 포함해 응답시간은 2RTT + 파일 전송 시간이 된다.</li>
</ul>
<h2>지속성 연결</h2>
<p>이미 한번 확인한 socket을 계속 사용하기 때문에 비지속성 연결에 비해 RTT 한번의 시간을 줄일 수 있다.</p>
<h2>HTTP 프로토콜 구주</h2>
<p>HTTP 요청 메세지에서는 요청라인이 있고 응답 메세지에서는 상태라인이 있다. 그 후부터는 둘 다 메세지 정보를 담는 헤더 부분과 공백을 두고 본문이 있다.</p>
<h2>Method types</h2>
<p>HTTP 1.0</p>
<ul>
<li>GET: url의 웹 문서 정보 요청</li>
<li>HEAD: 문서 내용보다 특정 문서에 대한 정보 요청</li>
<li>POST: 서버에 정보를 전송
HTTP 1.1</li>
<li>GET, POST, HEAD</li>
<li>PUT: 데이터 패치</li>
<li>DELETE: 데이터 제거</li>
</ul>
<h2>Uploading form input</h2>
<p>body에다가 요청할 키워드를 넣는 것을 POST method, URL에 붙여서 요청하는 것을 URLMethod라고 한다.</p>
<h2>HTTP response status code</h2>
<ul>
<li>200: OK</li>
<li>301: Moved Permanently</li>
<li>400: Bad Request</li>
<li>404: Not Found</li>
<li>505: HTTP Version Not Supported</li>
</ul>
<h2>Cookies</h2>
<p>server에서 client에 번호를 부여하는데 이를 쿠키라고 한다. 그리고 client와 server가 통신을 할 때마다 쿠키가 따라 붙어 server에서는 이 쿠키를 확인하고 기록을 알아낼 수 있다.</p>
<p>웹에서는 정보를 저장할 수 없었는데 쿠키를 이용하여 단점을 보안할 수 있다. 하지만 privacy에 문제가 생길 수 있다.</p>
<h2>Web caches</h2>
<p>쿠키는 server에서 기억하고 있는 것이었지만 웹 캐시는 client에 저장되어있다.
처음에 server에 바로 접근하는 것이 아니라 먼저 proxy server에 있는 캐시를 읽어 속도를 향상시킨다.</p>
